package com.citycreek.of;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.cjc.util.AppUtil;
import com.cjc.util.Format42;
import com.cjc.util.LangUtil;
import com.cjc.util.PropertiesUtil;

public class OrderFulfillment {

	private static final Logger log = Logger.getLogger(OrderFulfillment.class.getName());

	private static final String VERSION = "v1.1 - 24 October 2016";

	private static PropertiesUtil props = new PropertiesUtil();
	private static List<Order> orders = new ArrayList<Order>();
	private static Map<String, Customer> customers = new HashMap<>();

	public static void main(String[] args) {
		try {
			setup(args);
			readCustomerXml();
			readOrderXml();
			orders.forEach(OrderFulfillment::associateCustomerToOrder);
			final List<String> removeDuplicates = removeDuplicates();
			writeQuickBooksIFF();
			final Path csvFile = writeCsv();
			ftpCsv(csvFile);

			// Print dups at the end.
			info("*************************************************************************");
			for (String dup : removeDuplicates) {
				info(dup);
			}
		} catch (Throwable e) {
			info("Unknown serious error", e);
		}
		info("*************************************************************************");
		info("DONE!");
		info("*************************************************************************");
		System.exit(0);
	}

	private static void info(String msg) {
		info(msg, null);
	}

	private static void info(String msg, Throwable e) {
		if (e != null) {
			log.log(Level.WARNING, msg, e);
			System.out.println("ERROR: " + msg + "; " + e.getMessage());
		} else {
			log.info(msg);
			System.out.println(msg);
		}
	}

	/**
	 * Setup the application; properties, logging, etc.
	 */
	private static void setup(String[] args) {
		// Command-line arguments
		final Properties argProps = AppUtil.getCommandLineProperties(args);
		props.setFromAnother(argProps);

		// Load application properties from file
		final String confFilename = props.getOptional(AppProperties.CONFIG_FILENAME, "config.properties");
		props.load(confFilename);

		// Logging
		final String loggingFilename = props.getOptional(AppProperties.LOGGING_CONFIG_FILENAME, "logging.properties");
		if (LangUtil.hasValue(loggingFilename)) {
			try {
				AppUtil.readConfig(loggingFilename);
			} catch (IOException e) {
				info("Unable to read logging properties, using VM defaults.", e);
			}
		} else {
			info("Unable to read logging properties, using VM defaults.");
		}
		Format42.use(props.getProperties());

		OrderDetail.loadShippingExcludedProducts(props);

		info("*************************************************************************");
		info("** CityCreek Order Fulfillment");
		info("** " + VERSION);
		info("*************************************************************************");
		log.config("currentTimeMillis=" + System.currentTimeMillis());
		props.dumpProperties(log, Level.CONFIG);
		log.config("*************************************************************************");
	}

	public static void associateCustomerToOrder(Order o) {
		String customerId = o.getCustomerID();
		if (LangUtil.hasValue(customerId)) {
			o.setCustomer(customers.get(customerId));
		} else {
			log.warning("No customer found for order=" + customerId);
		}
	}

	public static void readOrderXml() throws Exception {
		info("Retrieving ORDERS XML file...");
		String xmlFile = props.getOptional(AppProperties.XML_ORDER_FILE);
		if (LangUtil.hasValue(xmlFile)) {
			xmlFile = props.getOptional(AppProperties.XML_DIR, "xml") + "/" + xmlFile;
			info("  Read from file, " + xmlFile);
			final File file = new File(xmlFile);
			if (file.length() > 0) {
				new OrderXmlTransformer().fromXml(file, orders);
			}
		} else {
			readOrdersFromUrl();
		}
	}

	public static void readCustomerXml() throws Exception {
		info("Retrieving CUSTOMERS XML file...");
		String xmlFile = props.getOptional(AppProperties.XML_CUSTOMER_FILE);
		if (LangUtil.hasValue(xmlFile)) {
			xmlFile = props.getOptional(AppProperties.XML_DIR, "xml") + "/" + xmlFile;
			info("  Read from file, " + xmlFile);
			final File file = new File(xmlFile);
			if (file.length() > 0) {
				new CustomerXmlTransformer().fromXml(file, customers);
			}
		} else {
			readCustomersFromUrl();
		}
	}

	private static void readOrdersFromUrl() throws Exception {
		final String username = props.getRequired(AppProperties.VOLUSION_USERNAME);
		final String password = props.getRequired(AppProperties.VOLUSION_PASSWORD);

		// Determine the XML file URL from properties.
		final String xmlUrl;
		{
			final String urlProperty = props.getRequired(AppProperties.XML_ORDER_URL);
			final String columns = Order.XML_COLUMNS + "," + OrderDetail.XML_COLUMNS;
			xmlUrl = MessageFormat.format(urlProperty, username, password, columns);
			info("  Read ORDERS from URL, " + urlProperty);
		}
		// Output filename
		final String filename = LangUtil.getDateTimeString(new Date(), "yyyyMMddHHmm");
		final String xmlFile = props.getOptional(AppProperties.XML_DIR, "xml") + "/" + filename + "_order.xml";
		info("  Write to file, " + xmlFile);

		// Read in the orders from Volution.
		try (InputStream in = new URL(xmlUrl).openStream()) {
			Files.copy(in, Paths.get(xmlFile));
		}

		log.fine("  Parsing XML file...");
		final File file = new File(xmlFile);
		if (file.length() > 0) {
			new OrderXmlTransformer().fromXml(file, orders);
		}
	}

	private static void readCustomersFromUrl() throws Exception {
		final String username = props.getRequired(AppProperties.VOLUSION_USERNAME);
		final String password = props.getRequired(AppProperties.VOLUSION_PASSWORD);

		// Determine the XML file URL from properties.
		String xmlUrl;
		{
			final String urlProperty = props.getRequired(AppProperties.XML_CUSTOMER_URL);
			xmlUrl = MessageFormat.format(urlProperty, username, password, Customer.XML_COLUMNS);
			info("  Read CUSTOMERS from URL, " + xmlUrl);
		}
		// Output filename
		final String filename = LangUtil.getDateTimeString(new Date(), "yyyyMMddHHmm");
		final String xmlFile = props.getOptional(AppProperties.XML_DIR, "xml") + "/" + filename + "_customer.xml";
		info("  Write to file, " + xmlFile);

		// Read in the orders from Volution.
		try (InputStream in = new URL(xmlUrl).openStream()) {
			Files.copy(in, Paths.get(xmlFile));
		}
		log.fine("  Parsing XML file...");
		final File file = new File(xmlFile);
		if (file.length() > 0) {
			new CustomerXmlTransformer().fromXml(file, customers);
		}
	}

	/**
	 * @return duplicates messages
	 */
	private static List<String> removeDuplicates() {
		final String columnsProperty = props.getRequired(AppProperties.XML_DUPLICATE_COLUMNS);
		final String[] columns = columnsProperty.split(",");

		// For each order, look to see if the current order is the same as the
		// previous.
		final List<Long> removals = new ArrayList<>();
		final List<String> removalLogs = new ArrayList<>();
		Order prevOrder = null;
		for (Order order : orders) {
			if (prevOrder == null) {
				prevOrder = order;
				continue; // skip first one
			}

			final long prevOrderId = prevOrder.getOrderID();
			final long currOrderId = order.getOrderID();
			if (prevOrderId != (currOrderId - 1)) {
				prevOrder = order;
				continue; // not sequential, so not a duplicate, moving on
			}

			// For each column, check to see if they all match
			boolean eq = true;
			String currId = null;
			for (String col : columns) {
				final String colName = col.trim();
				if (!LangUtil.hasValue(colName)) {
					continue; // skip these empty columns
				}
				final String prev = prevOrder.getColumnByName(colName);
				final String curr = order.getColumnByName(colName);
				if (!Objects.equals(prev, curr)) {
					eq = false;
					break; // not equal so not duplicate
				}
			} // for each column

			// Must be equal
			if (eq) {
				removals.add(prevOrder.getOrderID());
				removalLogs.add("DUPLICATE: +" + currId + " equals -" + prevOrder.getOrderID());
			}

			prevOrder = order;
		} // for each order

		// Remove orders
		orders.removeIf((order) -> removals.contains(order.getOrderID()));

		return removalLogs;
	}

	private static Path writeQuickBooksIFF() throws IOException {
		info("Creating QuickBooks IIF file...");
		QuickBooksExporter exporter = new QuickBooksExporter(Paths.get(props.getRequired(AppProperties.IIF_DIR)))
				.exportOrders(orders);

		exporter.appendHeader();

		// write to disk
		Path file = exporter.write();
		info("  Orders:   " + exporter.getOrderIds());
		info("  Wrote " + exporter.getCount() + " lines to " + file);
		return file;
	}

	private static Path writeCsv() throws IOException {
		info("Creating CSV file...");
		CSVExporter exporter = new CSVExporter(Paths.get(props.getRequired(AppProperties.CSV_DIR))).exportOrders(orders);

		// write to disk
		Path file = exporter.write();
		info("  Excluded: " + OrderDetail.EXCLUDED_PRODUCTS);
		info("  Orders:   " + exporter.getOrderIds());
		info("  Wrote " + exporter.getCount() + " lines to " + file);
		return file;
	}

	private static void ftpCsv(Path csvFile) throws IOException {
		final boolean enabled = props.getRequiredBoolean(AppProperties.FTP_ENABLED);
		if (!enabled) {
			info("FTP Disabled");
			return;
		}
		info("Sending file to FTP site...");
		final String urlString = props.getRequired(AppProperties.FTP_URL) + csvFile.getFileName() + ";type=i";
		log.fine("  Remote=" + urlString);

		final String localCsvFile = props.getOptional(AppProperties.CSV_DIR, "csv") + "/" + csvFile;
		log.fine("  Local=" + localCsvFile);
		try (OutputStream out = new URL(urlString).openConnection().getOutputStream()) {
			Files.copy(Paths.get(localCsvFile), out);
		}
	}
}
